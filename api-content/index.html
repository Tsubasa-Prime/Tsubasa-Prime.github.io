{"posts":[{"title":"Vim 命令","content":"在安装 Vim 之后 输入 vimtutor 可阅读教程 1. 欲从当前光标删除至下一个单词，请输入：dw 2. 欲从当前光标删除至当前行末尾，请输入：d$ 3. 欲删除整行，请输入：dd 4. 欲重复一个动作，请在它前面加上一个数字：2w 5. 在正常模式下修改命令的格式是： operator [number] motion 其中： operator - 操作符，代表要做的事情，比如 d 代表删除 [number] - 可以附加的数字，代表动作重复的次数 motion - 动作，代表在所操作的文本上的移动，例如 w 代表单词(word)， $ 代表行末等等。 6. 欲移动光标到行首，请按数字0键：0 7. 欲撤消以前的操作，请输入：u (小写的u) 欲撤消在一行中所做的改动，请输入：U (大写的U) 欲撤消以前的撤消命令，恢复以前的操作结果，请输入：CTRL-R 1. 要重新置入已经删除的文本内容，请按小写字母 p 键。该操作可以将已删除 的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置 于当前光标所在行的下一行。 2. 要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字 符即可。 3. 更改类命令允许您改变从当前光标所在位置直到动作指示的位置中间的文本。 比如输入 ce 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当 前光标到行末的内容。 4. 更改类命令的格式是： c [number] motion 1. CTRL-G 用于显示当前光标所在位置和文件状态信息。 G 用于将光标跳转至文件最后一行。 先敲入一个行号然后输入大写 G 则是将光标移动至该行号代表的行。 gg 用于将光标跳转至文件第一行。 2. 输入 / 然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。 输入 ? 然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。 完成一次查找之后按 n 键是重复上一次的命令，可在同一方向上查 找下一个匹配字符串所在；或者按大写 N 向相反方向查找下一匹配字符串所在。 CTRL-O 带您跳转回较旧的位置，CTRL-I 则带您到较新的位置。 3. 如果光标当前位置是括号(、)、[、]、{、}，按 % 会将光标移动到配对的括号上。 4. 在一行内替换头一个字符串 old 为新的字符串 new，请输入 :s/old/new 在一行内替换所有的字符串 old 为新的字符串 new，请输入 :s/old/new/g 在两行内替换所有的字符串 old 为新的字符串 new，请输入 :#,#s/old/new/g 在文件内替换所有的字符串 old 为新的字符串 new，请输入 :%s/old/new/g 进行全文替换时询问用户确认每个替换需添加 c 标志 :%s/old/new/gc ``` ```text 1. :!command 用于执行一个外部命令 command。 请看一些实际例子： (MS-DOS) (Unix) :!dir :!ls - 用于显示当前目录的内容。 :!del FILENAME :!rm FILENAME - 用于删除名为 FILENAME 的文件。 2. :w FILENAME 可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文 件中。 3. v motion :w FILENAME 可将当前编辑文件中可视模式下选中的内容保存到文件 FILENAME 中。 4. :r FILENAME 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置 后面。 5. :r !dir 可以读取 dir 命令的输出并将其放置到当前文件的光标位置后面。 1. 输入小写的 o 可以在光标下方打开新的一行并进入插入模式。 输入大写的 O 可以在光标上方打开新的一行。 2. 输入小写的 a 可以在光标所在位置之后插入文本。 输入大写的 A 可以在光标所在行的行末之后插入文本。 3. e 命令可以使光标移动到单词末尾。 4. 操作符 y 复制文本，p 粘贴先前复制的文本。 5. 输入大写的 R 将进入替换模式，直至按 &lt;ESC&gt; 键回到正常模式。 6. 输入 :set xxx 可以设置 xxx 选项。一些有用的选项如下： 'ic' 'ignorecase' 查找时忽略字母大小写 'is' 'incsearch' 查找短语时显示部分匹配 'hls' 'hlsearch' 高亮显示所有的匹配短语 选项名可以用完整版本，也可以用缩略版本。 7. 在选项前加上 no 可以关闭选项： :set noic ","link":"https://tsubasaprime.net/vimOrder/"},{"title":"Golang 多线程图片爬取","content":"package main import ( &quot;strconv&quot; &quot;net/http&quot; &quot;io/ioutil&quot; &quot;github.com/anaskhan96/soup&quot; // . &quot;fmt&quot; &quot;sync&quot; &quot;runtime&quot; ) var ( wg sync.WaitGroup foo int lock sync.Mutex pageNum int ) func pageSpider(pageUrl string, urlChannle chan string, wait chan int) { soup.Header(&quot;user-agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36&quot;) source, _ := soup.Get(pageUrl) for _, bar := range soup.HTMLParse(source).Find(&quot;ul&quot;, &quot;id&quot;, &quot;post-list-posts&quot;).FindAll(&quot;li&quot;) { urlChannle &lt;- bar.FindAll(&quot;a&quot;)[1].Attrs()[&quot;href&quot;] } wait &lt;- 1 } func save(urlChannle chan string) { for i := range urlChannle { res, _ := http.Get(i) defer res.Body.Close() data, _ := ioutil.ReadAll(res.Body) // 防止数据异常 lock.Lock() _ = ioutil.WriteFile(&quot;/home/tsubasa/图片/photo/&quot; + strconv.Itoa(foo) + &quot;.jpg&quot;, data, 0755) foo ++ lock.Unlock() } defer wg.Done() } func main() { // 设置运行的 CPU 核数 runtime.GOMAXPROCS(4) // 爬取的页面数量 pageNum = 100 urlChannle := make(chan string, 20) wait := make(chan int) // 调度器 go func() { for i := 0; i &lt; pageNum; i ++ { &lt;-wait } close(urlChannle) }() for i := 1; i &lt; pageNum + 1; i ++ { go pageSpider(&quot;https://konachan.net/post?page=&quot;+ strconv.Itoa(i) +&quot;&amp;tags=&quot;, urlChannle, wait) } for i := 0; i &lt; 4; i ++ { wg.Add(1) go save(urlChannle) } wg.Wait() } ","link":"https://tsubasaprime.net/goSpider/"},{"title":"Golang 线程之间的数据同步","content":"一对一 package main import ( . &quot;fmt&quot; ) func main() { foo := make(chan int) // 启动写入线程 go func() { for i := 0; i &lt; 20; i ++ { foo &lt;- i } close(foo) }() //读取数据 for i := range foo { Println(i) } } 一对多 package main import ( . &quot;fmt&quot; &quot;sync&quot; ) var wg sync.WaitGroup func main() { foo := make(chan int) // 启动写入线程 go func() { for i := 0; i &lt; 20; i ++ { foo &lt;- i } close(foo) }() // 启动读取线程 for i := 0; i &lt; 4; i ++ { wg.Add(1) go func() { for i := range foo { Println(i) } defer wg.Done() }() } // 等待所有数据读取完成 wg.Wait() } 多对一 package main import ( . &quot;fmt&quot; ) func main() { // 写入函数的线程数 num := 4 // 缓存为 10 foo := make(chan int, 10) bar := make(chan int) // 监控是否全部写入 go func() { for i := 0; i &lt; num; i ++ { &lt;-bar } close(foo) }() // 启动写入线程 for i := 0; i &lt; num; i ++ { go func() { for i := 0; i &lt; 20; i ++ { foo &lt;- i } bar &lt;- 1 }() } // 读取数据 for i := range foo { Println(i) } } 多对多 package main import ( . &quot;fmt&quot; &quot;sync&quot; ) var wg sync.WaitGroup func main() { // 写入函数的线程数 inNum := 4 // 读取函数的线程数 outNum := 4 // 缓存为 10 foo := make(chan int, 10) bar := make(chan int) // 监控是否全部写入 go func() { for i := 0; i &lt; inNum; i ++ { &lt;-bar } close(foo) }() // 启动写入线程 for i := 0; i &lt; inNum; i ++ { go func() { for i := 0; i &lt; 20; i ++ { foo &lt;- i } bar &lt;- 1 }() } // 读取数据 for i:= 0; i &lt; outNum; i ++ { wg.Add(1) go func() { for i := range foo { Println(i) } defer wg.Done() }() } // 等待所有数据读出 wg.Wait() } ","link":"https://tsubasaprime.net/goDataSync/"},{"title":"Dwm 安装与配置","content":"安装 sudo pacman -S base-devel # 安装开发工具集 # 安装 x 组件 sudo pacman -S xorg-server sudo pacman -S xorg-apps sudo pacman -S xorg-xinit sudo pacman -S noto-fonts-cjk # 安装字体 # 下载 Dwm 源码 git clone https://git.suckless.org/dwm 配置 将 config.def.h 复制成 config.h 47 #define MODKEY Mod1Mask // MODKEY1 是左 ALT 键 60 static const char *termcmd[] = { &quot;st&quot;, NULL }; // 默认终端为 st 65 { MODKEY|ShiftMask, XK_Return, spawn, {.v = termcmd } }, // Alt + Shift + Enter 打开终端 启动 # 编译启动 Dwm sudo make sudo make install # 在文件最后一行加入 exec dwm vim .bashrc # 如果没有意外，则可以进入 Dwm 桌面环境 startx 意外 如果使用 sddm 启动器，在输入密码之后会出现进不去桌面环境的情况。 这是因为在 /usr/share/xsessions/ 中没有找到需要的 .desktop 文件，我们只需要在目录下加入 dwm.desktop 后重启即可进入桌面系统 [Desktop Entry] Name=dwm Comment=Dynamic Window Manager Exec=/usr/local/bin/dwm TryExec=/usr/local/bin/dwm Icon=/dwm.png Type=Application ","link":"https://tsubasaprime.net/dwmInstall/"},{"title":"Golang 安装与配置","content":"安装 命令行安装 # Arch 发行版 sudo pacman -S go # Ubuntu 发行版 sudo apt-get-repository ppa:gophers/go sudo apt-get update sudo apt-get install golang-stable 环境配置 # 查看与 Golang 有关的环境变量 go env # 修改 $HOME/GO 为 Golang 的工作目录 go env -w GOPATH=$HOME/GO GOPATH 目录下有三个文件 tree -L 1 -d . ├── bin # 编译后生成的可执行文件 ├── pkg # 编译后生成的文件 └── src # 存放源代码 ","link":"https://tsubasaprime.net/goInstall/"},{"title":"CNN(卷积神经网络)","content":"卷积神经网络是近年发展起来， 并引起广泛重视的一种高效识别方法。 import torch import torch.nn as nn import torchvision import torch.utils.data as Data from torch.autograd import Variable EPOCH = 3 # 训练三次 BATCH_SIZE = 50 # 一次训练的样本数量 LR = 0.001 # 学习率 train_data = torchvision.datasets.MNIST( root = '../data', train = True, transform = torchvision.transforms.ToTensor(), download = False ) test_data = torchvision.datasets.MNIST( root = '../data', train = False, transform = torchvision.transforms.ToTensor() ) train_loader = Data.DataLoader( dataset = train_data, batch_size = BATCH_SIZE, shuffle = True ) test_loader = Data.DataLoader( dataset = train_data, batch_size = BATCH_SIZE, shuffle = False ) class CNN(nn.Module) : def __init__(self) : super(CNN, self).__init__() self.layer1 = nn.Sequential( nn.Conv2d( in_channels = 1, out_channels = 16, kernel_size = 5, stride = 1, # 步长 padding = 2, # 补0 groups = 1 ), nn.ReLU(), nn.MaxPool2d(kernel_size = 2) ) self.layer2 = nn.Sequential( nn.Conv2d( in_channels = 16, out_channels = 32, kernel_size = 5, stride = 1, # 步长 padding = 2 # 补0 ), nn.ReLU(), nn.MaxPool2d(kernel_size = 2) ) self.layer3 = nn.Linear(32 * 7 * 7, 10) def forward(self, x) : x = self.layer1(x) x = self.layer2(x) x = x.view(x.size(0), -1) x = self.layer3(x) return x cnn = CNN().cuda() optimizer = torch.optim.Adam(cnn.parameters(), lr = LR) loss = nn.CrossEntropyLoss() for epoch in range(EPOCH) : for step, (b_x, b_y) in enumerate(train_loader) : output = cnn(Variable(b_x).cuda()) loss_ = loss(output, Variable(b_y).cuda()) optimizer.zero_grad() loss_.backward() optimizer.step() print(&quot;训练成功&quot;) cnn.eval() correct = 0 total = 0 for images, labels in test_loader : image = Variable(images).cuda() labels = Variable(labels).cuda() output = cnn(image).cuda() _, predicted = torch.max(output.data, 1) total += labels.size(0) correct += (predicted.cpu() == labels.cpu()).sum() print(&quot;测试准确率 : %f %%&quot; % (100 * correct / total)) 最后输出结果为 训练成功 测试准确率 : 99.000000 % 比逻辑回归的正确率高出 18%! ","link":"https://tsubasaprime.net/cnn/"}]}
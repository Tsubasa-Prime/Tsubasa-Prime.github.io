{"posts":[{"title":"Dwm 安装与配置","content":"Dwm 轻量级动态桌面管理器 安装 sudo pacman -S base-devel # 安装开发工具集 # 安装 x 组件 sudo pacman -S xorg-server sudo pacman -S xorg-apps sudo pacman -S xorg-xinit sudo pacman -S noto-fonts-cjk # 安装字体 # 下载 Dwm 源码 git clone https://git.suckless.org/dwm 配置 将 config.def.h 复制成 config.h 47 #define MODKEY Mod1Mask // MODKEY1 是左 ALT 键 60 static const char *termcmd[] = { &quot;st&quot;, NULL }; // 默认终端为 st 65 { MODKEY|ShiftMask, XK_Return, spawn, {.v = termcmd } }, // Alt + Shift + Enter 打开终端 启动 # 编译启动 Dwm sudo make sudo make install # 在文件最后一行加入 exec dwm vim .bashrc # 如果没有意外，则可以进入 Dwm 桌面环境 startx 意外 如果使用 sddm 启动器，在输入密码之后会出现进不去桌面环境的情况。 这是因为在 /usr/share/xsessions/ 中没有找到需要的 .desktop 文件，我们只需要在目录下加入 dwm.desktop 后重启即可进入桌面系统 [Desktop Entry] Name=dwm Comment=Dynamic Window Manager Exec=/usr/local/bin/dwm TryExec=/usr/local/bin/dwm Icon=/dwm.png Type=Application ","link":"https://tsubasaprime.net/dwm-install/"},{"title":"Golang 安装与配置","content":"安装 命令行安装 # Arch 发行版 sudo pacman -S go # Ubuntu 发行版 sudo apt-get-repository ppa:gophers/go sudo apt-get update sudo apt-get install golang-stable 环境配置 # 查看与 Golang 有关的环境变量 go env # 修改 $HOME/GO 为 Golang 的工作目录 go env -w GOPATH=$HOME/GO GOPATH 目录下有三个文件 tree -L 1 -d . ├── bin # 编译后生成的可执行文件 ├── pkg # 编译后生成的文件 └── src # 存放源代码 ","link":"https://tsubasaprime.net/go-install/"},{"title":"CNN(卷积神经网络)","content":"卷积神经网络是近年发展起来， 并引起广泛重视的一种高效识别方法。 import torch import torch.nn as nn import torchvision import torch.utils.data as Data from torch.autograd import Variable EPOCH = 3 # 训练三次 BATCH_SIZE = 50 # 一次训练的样本数量 LR = 0.001 # 学习率 train_data = torchvision.datasets.MNIST( root = '../data', train = True, transform = torchvision.transforms.ToTensor(), download = False ) test_data = torchvision.datasets.MNIST( root = '../data', train = False, transform = torchvision.transforms.ToTensor() ) train_loader = Data.DataLoader( dataset = train_data, batch_size = BATCH_SIZE, shuffle = True ) test_loader = Data.DataLoader( dataset = train_data, batch_size = BATCH_SIZE, shuffle = False ) class CNN(nn.Module) : def __init__(self) : super(CNN, self).__init__() self.layer1 = nn.Sequential( nn.Conv2d( in_channels = 1, out_channels = 16, kernel_size = 5, stride = 1, # 步长 padding = 2, # 补0 groups = 1 ), nn.ReLU(), nn.MaxPool2d(kernel_size = 2) ) self.layer2 = nn.Sequential( nn.Conv2d( in_channels = 16, out_channels = 32, kernel_size = 5, stride = 1, # 步长 padding = 2 # 补0 ), nn.ReLU(), nn.MaxPool2d(kernel_size = 2) ) self.layer3 = nn.Linear(32 * 7 * 7, 10) def forward(self, x) : x = self.layer1(x) x = self.layer2(x) x = x.view(x.size(0), -1) x = self.layer3(x) return x cnn = CNN().cuda() optimizer = torch.optim.Adam(cnn.parameters(), lr = LR) loss = nn.CrossEntropyLoss() for epoch in range(EPOCH) : for step, (b_x, b_y) in enumerate(train_loader) : output = cnn(Variable(b_x).cuda()) loss_ = loss(output, Variable(b_y).cuda()) optimizer.zero_grad() loss_.backward() optimizer.step() print(&quot;训练成功&quot;) cnn.eval() correct = 0 total = 0 for images, labels in test_loader : image = Variable(images).cuda() labels = Variable(labels).cuda() output = cnn(image).cuda() _, predicted = torch.max(output.data, 1) total += labels.size(0) correct += (predicted.cpu() == labels.cpu()).sum() print(&quot;测试准确率 : %f %%&quot; % (100 * correct / total)) 最后输出结果为 训练成功 测试准确率 : 99.000000 % 比逻辑回归的正确率高出 18%! ","link":"https://tsubasaprime.net/cnn/"}]}